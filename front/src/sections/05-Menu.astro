---
// Menu Section
const baseUrl = import.meta.env.BASE_URL;
const menuItems = [
    {
        name: '焼き餃子',
        price: '¥550',
        description: '極薄の皮でお肉の旨みがダイレクトに伝わる<br>一口サイズの焼き餃子（ニラニンニク・シソ・ショウガ）',
        image: `${baseUrl}images/menu-1.webp`
    },
    {
        name: '水餃子',
        price: '¥280',
        description: 'つるんともちもち、口の中でとろける<br>茹でたてのぷりぷり食感をぜひ',
        image: `${baseUrl}images/menu-2.webp`
    },
    {
        name: 'ドライカレー',
        price: '¥600',
        description: 'スパイス香る、やみつきの一皿<br>常連さんのリクエストで定番入り',
        image: `${baseUrl}images/menu-3.webp`
    }
];
---

<section id="menu" class="menu">
    <h2 class="menu__title">MENU</h2>

    <!-- メイン表示エリア -->
    <div class="menu__main">
        <div class="menu__main-image-container">
            <img id="menu-main-image-back" class="menu__main-image menu__main-image--back" src="" alt="" width="200" height="200" loading="lazy">
            <img id="menu-main-image-front" class="menu__main-image menu__main-image--front" src="" alt="" width="200" height="200" loading="lazy">
        </div>
        <p id="menu-name" class="menu__name"></p>
        <p id="menu-price" class="menu__price"></p>
        <p id="menu-description" class="menu__description"></p>
    </div>

    <!-- サムネイルカルーセル（無限ループ） -->
    <div class="menu__carousel">
        <div class="menu__carousel-track">
            <!-- JSで生成 -->
        </div>
    </div>
</section>

<script define:vars={{ menuItems }}>
    window.menuItems = menuItems;
</script>

<script>
    interface MenuItem {
        name: string;
        price: string;
        description: string;
        image: string;
    }
    declare global {
        interface Window {
            menuItems: MenuItem[];
        }
    }

    (function initMenuCarousel() {
        const menuItems = window.menuItems;
        const carousel = document.querySelector('.menu__carousel') as HTMLElement | null;
        const track = document.querySelector('.menu__carousel-track') as HTMLElement | null;
        const frontImage = document.getElementById('menu-main-image-front') as HTMLImageElement | null;
        const backImage = document.getElementById('menu-main-image-back') as HTMLImageElement | null;
        const nameEl = document.getElementById('menu-name') as HTMLElement | null;
        const priceEl = document.getElementById('menu-price') as HTMLElement | null;
        const descEl = document.getElementById('menu-description') as HTMLElement | null;

        if (!carousel || !track || !frontImage || !backImage || !nameEl || !priceEl || !descEl || menuItems.length === 0) return;

        // 設定
        const INITIAL_SETS = 3;
        const MAX_SETS = 10;
        const ITEM_WIDTH = 80;
        const LOAD_THRESHOLD = ITEM_WIDTH * 4;

        let currentSets = 0;
        let currentSlideIndex = 0;  // slideIndexを追跡（ユニークID）
        let isScrolling = false;
        let isLoading = false;
        let slides: HTMLElement[] = [];

        function createSlide(item: MenuItem, realIndex: number, slideIndex: number): HTMLElement {
            const slide = document.createElement('div');
            slide.className = 'menu__slide';
            slide.dataset.realIndex = String(realIndex);
            slide.dataset.slideIndex = String(slideIndex);

            const img = document.createElement('img');
            img.src = item.image;
            img.alt = item.name;
            img.className = 'menu__thumb';
            img.loading = 'lazy';

            slide.appendChild(img);

            slide.addEventListener('click', () => {
                const si = parseInt(slide.dataset.slideIndex || '0');
                if (si === currentSlideIndex) return;

                const scrollCenter = carousel!.scrollLeft + carousel!.clientWidth / 2;
                const slideCenter = slide.offsetLeft + ITEM_WIDTH / 2;
                const direction = slideCenter > scrollCenter ? 1 : -1;

                const ri = parseInt(slide.dataset.realIndex || '0');
                currentSlideIndex = si;
                updateActiveState(si);
                updateMainDisplay(ri, direction);
                scrollToSlideByElement(slide);
            });

            return slide;
        }

        const spacer = document.createElement('div');
        spacer.className = 'menu__carousel-spacer';
        spacer.style.width = (carousel!.clientWidth / 2 - ITEM_WIDTH / 2) + 'px';
        track.appendChild(spacer);

        function appendSets(count: number): void {
            for (let s = 0; s < count && currentSets < MAX_SETS; s++) {
                menuItems.forEach((item: MenuItem, i: number) => {
                    const slideIndex = currentSets * menuItems.length + i;
                    const slide = createSlide(item, i, slideIndex);
                    track!.insertBefore(slide, spacer);
                });
                currentSets++;
            }
            slides = Array.from(track!.querySelectorAll('.menu__slide')) as HTMLElement[];
        }

        appendSets(INITIAL_SETS);

        let isMainImageAnimating = false;
        function updateMainDisplay(index: number, direction: number = 0): void {
            const item = menuItems[index];

            if (direction === 0 || isMainImageAnimating) {
                frontImage!.src = item.image;
                frontImage!.alt = item.name;
                backImage!.src = item.image;
                backImage!.alt = item.name;
                nameEl!.textContent = item.name;
                priceEl!.textContent = item.price;
                descEl!.innerHTML = item.description;
                return;
            }

            isMainImageAnimating = true;
            const rotateAngle = direction > 0 ? 360 : -360;

            backImage!.src = item.image;
            backImage!.alt = item.name;

            frontImage!.style.transition = 'transform 0.5s ease-out';
            backImage!.style.transition = 'transform 0.5s ease-out';
            frontImage!.style.transform = `rotate(${rotateAngle}deg)`;
            backImage!.style.transform = `rotate(${rotateAngle}deg)`;

            frontImage!.style.animation = 'crossover-fade 0.5s ease-out forwards';

            nameEl!.textContent = item.name;
            priceEl!.textContent = item.price;
            descEl!.innerHTML = item.description;

            setTimeout(() => {
                frontImage!.style.transition = 'none';
                backImage!.style.transition = 'none';
                frontImage!.style.transform = 'rotate(0deg)';
                backImage!.style.transform = 'rotate(0deg)';
                frontImage!.style.animation = '';
                frontImage!.style.opacity = '1';
                frontImage!.src = item.image;
                frontImage!.alt = item.name;
                frontImage!.offsetHeight;
                frontImage!.style.transition = '';
                backImage!.style.transition = '';
                isMainImageAnimating = false;
            }, 500);
        }

        function updateSlideScales(): void {
            const carouselCenter = carousel!.scrollLeft + carousel!.clientWidth / 2;

            slides.forEach((slide: HTMLElement) => {
                const slideCenter = slide.offsetLeft + ITEM_WIDTH / 2;
                const distance = Math.abs(carouselCenter - slideCenter);
                const scale = Math.max(0.8, 1 - (distance / ITEM_WIDTH) * 0.1);
                slide.style.transform = `scale(${scale})`;
            });
        }

        function updateActiveState(slideIndex: number): void {
            slides.forEach((slide: HTMLElement) => {
                const isActive = parseInt(slide.dataset.slideIndex || '0') === slideIndex;
                slide.classList.toggle('is-active', isActive);
            });
        }

        function scrollToSlideByElement(targetSlide: HTMLElement | null, smooth: boolean = true): void {
            if (!targetSlide) return;

            const slideCenter = targetSlide.offsetLeft + ITEM_WIDTH / 2;
            const scrollTarget = slideCenter - carousel!.clientWidth / 2;

            if (!smooth) {
                carousel!.scrollLeft = scrollTarget;
                return;
            }

            animateScrollTo(scrollTarget, 500);
        }

        function animateScrollTo(targetLeft: number, duration: number = 500): void {
            const startLeft = carousel!.scrollLeft;
            const distance = targetLeft - startLeft;
            const startTime = performance.now();

            isScrolling = true;

            function step(currentTime: number): void {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeOut = 1 - Math.pow(1 - progress, 3);

                carousel!.scrollLeft = startLeft + distance * easeOut;

                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    isScrolling = false;
                }
            }

            requestAnimationFrame(step);
        }

        function scrollToSlide(slideIndex: number, smooth: boolean = true): void {
            const targetSlide = slides[slideIndex];
            if (targetSlide) {
                scrollToSlideByElement(targetSlide, smooth);
            }
        }

        function checkAndLoadMore(): void {
            if (isLoading || currentSets >= MAX_SETS) return;

            const maxScroll = carousel!.scrollWidth - carousel!.clientWidth;

            if (carousel!.scrollLeft > maxScroll - LOAD_THRESHOLD) {
                isLoading = true;
                appendSets(2);
                updateActiveState(currentSlideIndex);
                setTimeout(() => { isLoading = false; }, 100);
            }
        }

        let scrollTimeout: ReturnType<typeof setTimeout> | null = null;
        let lastScrollLeft = carousel!.scrollLeft;
        let lastManualScrollLeft = carousel!.scrollLeft;
        carousel!.addEventListener('scroll', () => {
            checkAndLoadMore();
            updateSlideScales();

            const currentScrollLeft = carousel!.scrollLeft;

            if (isScrolling) {
                lastScrollLeft = currentScrollLeft;
                return;
            }

            if (scrollTimeout) clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                const scrollCenter = carousel!.scrollLeft + carousel!.clientWidth / 2;
                let closestIndex = 0;
                let closestDistance = Infinity;

                slides.forEach((slide: HTMLElement, i: number) => {
                    const slideCenter = slide.offsetLeft + ITEM_WIDTH / 2;
                    const distance = Math.abs(scrollCenter - slideCenter);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestIndex = i;
                    }
                });

                if (closestIndex !== currentSlideIndex) {
                    const scrollDirection = carousel!.scrollLeft > lastManualScrollLeft ? 1 : -1;
                    const realIndex = parseInt(slides[closestIndex].dataset.realIndex || '0');
                    currentSlideIndex = closestIndex;
                    updateActiveState(closestIndex);
                    updateMainDisplay(realIndex, scrollDirection);
                }
                lastManualScrollLeft = carousel!.scrollLeft;
            }, 100);

            lastScrollLeft = currentScrollLeft;
        }, { passive: true });

        carousel!.addEventListener('scrollend', () => {
            checkAndLoadMore();
        }, { passive: true });

        const initialSlideIndex = menuItems.length;  // 2セット目の最初
        currentSlideIndex = initialSlideIndex;
        updateActiveState(initialSlideIndex);
        updateMainDisplay(0);
        setTimeout(() => {
            scrollToSlide(initialSlideIndex, false);
            setTimeout(updateSlideScales, 100);
        }, 50);

        // 自動スライド
        const AUTO_SLIDE_INTERVAL = 2800;
        let autoSlideTimer: ReturnType<typeof setInterval> | null = null;
        let isAutoSlideEnabled = true;
        let slideDirection = 1;

        function autoSlide(): void {
            if (!isAutoSlideEnabled) return;

            const scrollCenter = carousel!.scrollLeft + carousel!.clientWidth / 2;
            let currentSlideIdx = 0;
            let closestDistance = Infinity;

            slides.forEach((slide: HTMLElement, idx: number) => {
                const slideCenter = slide.offsetLeft + ITEM_WIDTH / 2;
                const distance = Math.abs(scrollCenter - slideCenter);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    currentSlideIdx = idx;
                }
            });

            let nextSlideIdx = currentSlideIdx + slideDirection;

            if (nextSlideIdx >= slides.length - 1) {
                slideDirection = -1;
                nextSlideIdx = currentSlideIdx - 1;
            } else if (nextSlideIdx <= 0) {
                slideDirection = 1;
                nextSlideIdx = currentSlideIdx + 1;
            }

            if (nextSlideIdx < 0 || nextSlideIdx >= slides.length) return;

            const targetSlide = slides[nextSlideIdx];
            const nextRealIndex = parseInt(targetSlide.dataset.realIndex || '0');

            currentSlideIndex = nextSlideIdx;
            updateActiveState(nextSlideIdx);
            updateMainDisplay(nextRealIndex, slideDirection);
            scrollToSlideByElement(targetSlide);
        }

        function startAutoSlide(): void {
            if (autoSlideTimer || !isAutoSlideEnabled) return;
            autoSlideTimer = setInterval(autoSlide, AUTO_SLIDE_INTERVAL);
        }

        function stopAutoSlide(): void {
            isAutoSlideEnabled = false;
            if (autoSlideTimer) {
                clearInterval(autoSlideTimer);
                autoSlideTimer = null;
            }
        }

        carousel!.addEventListener('touchstart', stopAutoSlide, { passive: true });
        carousel!.addEventListener('mousedown', stopAutoSlide);
        carousel!.addEventListener('wheel', stopAutoSlide, { passive: true });

        let autoSlideStarted = false;

        function triggerAutoSlide(): void {
            if (autoSlideStarted || !isAutoSlideEnabled) return;
            autoSlideStarted = true;

            clearTimeout(delayTimer);
            carouselObserver.disconnect();

            autoSlide();
            startAutoSlide();
        }

        const delayTimer = setTimeout(triggerAutoSlide, 5000);

        const carouselObserver = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting) {
                triggerAutoSlide();
            }
        }, { threshold: 0 });
        carouselObserver.observe(carousel!);
    })();
</script>

<style is:global>
    .menu {
        padding: 3rem 1rem;
        text-align: center;
    }

    .menu__title {
        font-size: 1.25rem;
        letter-spacing: 0.2em;
        color: var(--color-primary);
        margin-bottom: 2rem;
    }

    .menu__main {
        margin-bottom: 2rem;
    }

    .menu__main-image-container {
        position: relative;
        width: 200px;
        height: 200px;
        margin: 0 auto 1rem;
    }

    .menu__main-image {
        position: absolute;
        top: 0;
        left: 0;
        width: 200px;
        height: 200px;
        border-radius: 50%;
        object-fit: cover;
    }

    .menu__main-image--back {
        z-index: 1;
    }

    .menu__main-image--front {
        z-index: 2;
    }

    @keyframes crossover-fade {
        0%   { opacity: 1; }
        25%  { opacity: 1; }
        75%  { opacity: 0; }
        100% { opacity: 0; }
    }

    .menu__name {
        font-size: 1.25rem;
        font-weight: 700;
        color: var(--color-primary);
        margin-bottom: 0.25rem;
    }

    .menu__price {
        font-size: 1rem;
        color: var(--color-text-sub);
        margin-bottom: 0.5rem;
    }

    .menu__description {
        font-size: 0.875rem;
        color: var(--color-text-sub);
        line-height: 1.6;
        height: 2.8rem;  /* 0.875rem × 1.6 × 2行 */
    }

    .menu__carousel {
        padding: 1rem 0;
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        -ms-overflow-style: none;
        overscroll-behavior-x: contain;
        max-width: 480px;
        margin: 0 auto;
    }

    .menu__carousel::-webkit-scrollbar {
        display: none;
    }

    .menu__carousel-track {
        position: relative;
        display: flex;
        gap: 16px;
        padding-left: calc(50% - 40px);
    }

    .menu__carousel-spacer {
        flex-shrink: 0;
    }

    .menu__slide {
        flex-shrink: 0;
        width: 80px;
        height: 80px;
        transition: transform 0.2s ease-out;
    }

    .menu__thumb {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        object-fit: cover;
        cursor: pointer;
        transition: transform 0.2s, opacity 0.2s;
        opacity: 0.6;
    }

    .menu__slide.is-active .menu__thumb {
        transform: scale(1.1);
        opacity: 1;
    }
</style>
